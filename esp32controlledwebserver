#EX-1 control led from the web page. this is the basic page. iska use hum waha karte hai jaha pass hum webpage se input le apne esp32 me aur led ko control lrenge
try:
  import usocket as socket
except:
  import socket
  
from machine import Pin
import network
import esp
esp.osdebug(None)
import gc
gc.collect()

ssid = "Airtel_tejv_3002"
password = "air73137"

station= network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid,password)
while station.isConnected()==False:
   pass
print("connection successful")
print(station.ifconfig())

led=Pin(22,Pin.OUT)

def web_page():
  if led.value() == 1:
    gpio_state="ON"
  else:
    gpio_state="OFF"
  
  html = """<html><head> <title>ESP Web Server</title> <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,"> <style>html{font-family: Helvetica; display:inline-block; margin: 0px auto; text-align: center;}
  h1{color: #0F3376; padding: 2vh;}p{font-size: 1.5rem;}.button{display: inline-block; background-color: #e7bd3b; border: none; 
  border-radius: 4px; color: white; padding: 16px 40px; text-decoration: none; font-size: 30px; margin: 2px; cursor: pointer;}
  .button2{background-color: #4286f4;}</style></head><body> <h1>ESP Web Server</h1> 
  <p>GPIO state: <strong>""" + gpio_state + """</strong></p><p><a href="/?led=on"><button class="button">ON</button></a></p>
  <p><a href="/?led=off"><button class="button button2">OFF</button></a></p></body></html>"""
  return html

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)

while True:
  conn, addr = s.accept()
  print('Got a connection from %s' % str(addr))
  request = conn.recv(1024)
  request = str(request)
  print('Content = %s' % request)
  led_on = request.find('/?led=on')
  led_off = request.find('/?led=off')
  if led_on == 6:
    print('LED ON')
    led.value(1)
  if led_off == 6:
    print('LED OFF')
    led.value(0)
  response = web_page()
  conn.send('HTTP/1.1 200 OK\n')
  conn.send('Content-Type: text/html\n')
  conn.send('Connection: close\n\n')
  conn.sendall(response)
  conn.close()

#EX-2 slider based led control and it works fine
try:
    import usocket as socket
except:
    import socket

from machine import Pin
import network

ssid = "Airtel_tejv_3002"
password = "air73137"

station = network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid, password)
while not station.isconnected():
    pass
print("Connection successful")
print(station.ifconfig())

led = Pin(2, Pin.OUT)  # Use Pin 2 for the built-in LED on ESP32

def web_page():
    led_state = "checked" if led.value() == 1 else ""
    
    html = """<!DOCTYPE html>
    <html>
    <head>
        <title>ESP Web Server</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <style>
            html {font-family: Arial; display: inline-block; text-align: center;}
            h2 {font-size: 3.0rem;}
            p {font-size: 3.0rem;}
            body {max-width: 600px; margin:0px auto; padding-bottom: 25px;}
            .switch {position: relative; display: inline-block; width: 120px; height: 68px} 
            .switch input {display: none}
            .slider {position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; border-radius: 34px}
            .slider:before {position: absolute; content: ""; height: 52px; width: 52px; left: 8px; bottom: 8px; background-color: #fff; -webkit-transition: .4s; transition: .4s; border-radius: 68px}
            input:checked + .slider {background-color: #2196F3}
            input:checked + .slider:before {-webkit-transform: translateX(52px); -ms-transform: translateX(52px); transform: translateX(52px)}
        </style>
    </head>
    <body>
        <h2>ESP32 Relay Control</h2>
        <label class="switch">
            <input type="checkbox" onchange="toggleCheckbox(this)" id="toggleSwitch" %s>
            <span class="slider"></span>
        </label>
        <p>Toggle Switch</p>
        
        <script>
            function toggleCheckbox(element) {
                var xhr = new XMLHttpRequest();
                if (element.checked) {
                    xhr.open("GET", "/?led=on", true);
                } else {
                    xhr.open("GET", "/?led=off", true);
                }
                xhr.send();
            }
        </script>
    </body>
    </html>""" % led_state
    return html

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)

while True:
    conn, addr = s.accept()
    print('Got a connection from %s' % str(addr))
    request = conn.recv(1024)
    request = str(request)
    print('Content = %s' % request)
    led_on = request.find('/?led=on')
    led_off = request.find('/?led=off')
    if led_on == 6:
        print('LED ON')
        led.value(1)
    if led_off == 6:
        print('LED OFF')
        led.value(0)
    
    response = web_page()
    conn.send(b'HTTP/1.1 200 OK\n')
    conn.send(b'Content-Type: text/html\n')
    conn.send(b'Connection: close\n\n')
    conn.sendall(response.encode('utf-8'))  # Encode HTML response to bytes before sending
    conn.close()

#STEp-3 react js code to make the similar functionality
import React, { useState, useEffect } from 'react';
import './ToggleSwitch.css'; // Import your CSS file for styling

const ToggleSwitch = () => {
    const [isChecked, setIsChecked] = useState(false);

    useEffect(() => {
        // Fetch initial state from ESP32 server
        fetch('/state')  // Replace with your ESP32 server endpoint
            .then(response => response.json())
            .then(data => setIsChecked(data.state === 'on'));  // Assuming your server responds with JSON containing state information
    }, []);

    const handleToggle = () => {
        const newState = isChecked ? 'off' : 'on';
        
        // Send state change request to ESP32 server
        fetch(`/?led=${newState}`)  // Replace with your ESP32 server endpoint
            .then(() => setIsChecked(!isChecked))
            .catch(error => console.error('Error toggling switch:', error));
    };

    return (
        <div className="toggle-switch-container">
            <h2>ESP32 Relay Control</h2>
            <label className="switch">
                <input type="checkbox" checked={isChecked} onChange={handleToggle} />
                <span className="slider"></span>
            </label>
            <p>Toggle Switch</p>
        </div>
    );
};

export default ToggleSwitch;

#step-2 this is my css code
.toggle-switch-container {
    font-family: Arial;
    text-align: center;
    max-width: 600px;
    margin: 0 auto;
    padding-bottom: 25px;
}

.switch {
    position: relative;
    display: inline-block;
    width: 120px;
    height: 68px;
}

.switch input {
    display: none;
}

.slider {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    border-radius: 34px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 52px;
    width: 52px;
    left: 8px;
    bottom: 8px;
    background-color: #fff;
    transition: .4s;
    border-radius: 68px;
}

.switch input:checked + .slider {
    background-color: #2196F3;
}

.switch input:checked + .slider:before {
    transform: translateX(52px);
}

#EXAMPLE- 3 bme sensor 
#step-1 boot.py

import esp
esp.osdebug(None)

import gc
gc.collect()

from bme680 import *

# ESP32 - Pin assignment
i2c = I2C(scl=Pin(22), sda=Pin(21))
# ESP8266 - Pin assignment
#i2c = I2C(scl=Pin(5), sda=Pin(4))

ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'

station = network.WLAN(network.STA_IF)

station.active(True)
station.connect(ssid, password)

while station.isconnected() == False:
  pass

print('Connection successful')
print(station.ifconfig())

#step-2 main.py
Random Nerd Tutorials
Free eBooks
 
About
 
Contact
 
Courses Login
 
Get Courses
 
HOME ESP32 ESP8266 ESP32-CAM RASPBERRY PI MICROPYTHON ARDUINO REVIEWS PROJECTS
MicroPython: ESP32/ESP8266 BME680 Web Server (Weather Station)
This tutorial is a step-by-step guide that covers how to build a standalone ESP32 or ESP8266 NodeMCU Web Server that displays BME680 sensor readings using MicroPython firmware. We’ll create an ESP32/ESP8266 Web Server that is mobile responsive and it can be accessed with any device with a browser in your local network.

MicroPython BME680 ESP32 ESP8266 Temperature Humidity Pressure Gas Web Server Guide
If you want to learn how a relay module works, read our MicroPython Guide: BME680 with ESP32 and ESP8266 (Temperature, Humidity, Pressure, Gas).

We have similar guides using Arduino IDE:

ESP32: BME680 Environmental Sensor using Arduino IDE (Gas, Pressure, Humidity, Temperature)
ESP8266 NodeMCU: BME680 Environmental Sensor using Arduino IDE (Gas, Pressure, Humidity, Temperature)
Prerequisites
To follow this tutorial you need MicroPython firmware installed in your ESP32 or ESP8266 boards. You also need an IDE to write and upload the code to your board. We suggest using Thonny IDE or uPyCraft IDE:

Thonny IDE:
Installing and getting started with Thonny IDE
Flashing MicroPython Firmware with esptool.py
uPyCraft IDE:
Getting Started with uPyCraft IDE
Install uPyCraft IDE (Windows, Mac OS X, Linux)
Flash/Upload MicroPython Firmware to ESP32 and ESP8266
Learn more about MicroPython: MicroPython Programming with ESP32 and ESP8266 eBook.

BME680 Environmental Sensor Module
The BME680 is an environmental sensor that combines gas, pressure, humidity and temperature sensors. The gas sensor can detect a broad range of gases like volatile organic compounds (VOC). For this reason, the BME680 can be used in indoor air quality control.

The BME680 supports I2C and SPI Interfaces.

BME680 Gas sensor humidity barometric pressure ambient temperature gas air quality back
BME680 I2C
This sensor communicates using I2C communication protocol, so the wiring is very simple. You can use the default ESP32 or ESP8266 I2C pins as shown in the following table:

BME680	ESP32	ESP8266
Vin	3.3V	3.3V
GND	GND	GND
SCL	GPIO 22	GPIO 5 (D1)
SDA	GPIO 21	GPIO 4 (D2)
Parts Required
ESP32 Board BME680 Gas sensor circuit wiring diagram schematics
For this project you need to wire the BME680 sensor module to the ESP32 or ESP8266 I2C pins. Here’s a list of parts you need for this tutorial:

BME680 sensor module
ESP32 or ESP8266 (read ESP32 vs ESP8266)
Breadboard
Jumper wires
You can use the preceding links or go directly to MakerAdvisor.com/tools to find all the parts for your projects at the best price!



Schematic – ESP32
Follow the next schematic diagram if you’re using an ESP32 board:

ESP32 BME680 Wiring Diagram I2C
Recommended reading: ESP32 Pinout Reference Guide

Schematic – ESP8266
Follow the next schematic diagram if you’re using an ESP8266 board:

ESP8266 NodeMCU BME680 Environmental Sensor Wiring Diagram I2C
Recommended reading: ESP8266 Pinout Reference Guide

BME680 MicroPython Library
The library to read from the BME680 sensor isn’t part of the standard MicroPython library by default. So, you need to upload the following library to your ESP32/ESP8266 board (save it with the name bme680.py).

# Spaces, comments and some functions have been removed from the original file to save memory
# Original source: https://github.com/adafruit/Adafruit_CircuitPython_BME680/blob/master/adafruit_bme680.py
import time
import math
from micropython import const
from ubinascii import hexlify as hex
try:
  import struct
except ImportError:
  import ustruct as struct
_BME680_CHIPID = const(0x61)
_BME680_REG_CHIPID = const(0xD0)
_BME680_BME680_COEFF_ADDR1 = const(0x89)
_BME680_BME680_COEFF_ADDR2 = const(0xE1)
_BME680_BME680_RES_HEAT_0 = const(0x5A)
_BME680_BME680_GAS_WAIT_0 = const(0x64)
_BME680_REG_SOFTRESET = const(0xE0)
_BME680_REG_CTRL_GAS = const(0x71)
_BME680_REG_CTRL_HUM = const(0x72)
_BME280_REG_STATUS = const(0xF3)
_BME680_REG_CTRL_MEAS = const(0x74)
_BME680_REG_CONFIG = const(0x75)
_BME680_REG_PAGE_SELECT = const(0x73)
_BME680_REG_MEAS_STATUS = const(0x1D)
_BME680_REG_PDATA = const(0x1F)
_BME680_REG_TDATA = const(0x22)
_BME680_REG_HDATA = const(0x25)
_BME680_SAMPLERATES = (0, 1, 2, 4, 8, 16)
_BME680_FILTERSIZES = (0, 1, 3, 7, 15, 31, 63, 127)
_BME680_RUNGAS = const(0x10)
_LOOKUP_TABLE_1 = (2147483647.0, 2147483647.0, 2147483647.0, 2147483647.0, 2147483647.0,
  2126008810.0, 2147483647.0, 2130303777.0, 2147483647.0, 2147483647.0,
  2143188679.0, 2136746228.0, 2147483647.0, 2126008810.0, 2147483647.0,
  2147483647.0)
_LOOKUP_TABLE_2 = (4096000000.0, 2048000000.0, 1024000000.0, 512000000.0, 255744255.0, 127110228.0,
  64000000.0, 32258064.0, 16016016.0, 8000000.0, 4000000.0, 2000000.0, 1000000.0,
  500000.0, 250000.0, 125000.0)
def _read24(arr):
  ret = 0.0
  for b in arr:
    ret *= 256.0
    ret += float(b & 0xFF)
  return ret
class Adafruit_BME680:
  def __init__(self, *, refresh_rate=10):
    self._write(_BME680_REG_SOFTRESET, [0xB6])
    time.sleep(0.005)
    chip_id = self._read_byte(_BME680_REG_CHIPID)
    if chip_id != _BME680_CHIPID:
      raise RuntimeError('Failed 0x%x' % chip_id)
    self._read_calibration()
    self._write(_BME680_BME680_RES_HEAT_0, [0x73])
    self._write(_BME680_BME680_GAS_WAIT_0, [0x65])
    self.sea_level_pressure = 1013.25
    self._pressure_oversample = 0b011
    self._temp_oversample = 0b100
    self._humidity_oversample = 0b010
    self._filter = 0b010
    self._adc_pres = None
    self._adc_temp = None
    self._adc_hum = None
    self._adc_gas = None
    self._gas_range = None
    self._t_fine = None
    self._last_reading = 0
    self._min_refresh_time = 1000 / refresh_rate
  @property
  def pressure_oversample(self):
    return _BME680_SAMPLERATES[self._pressure_oversample]
  @pressure_oversample.setter
  def pressure_oversample(self, sample_rate):
    if sample_rate in _BME680_SAMPLERATES:
      self._pressure_oversample = _BME680_SAMPLERATES.index(sample_rate)
    else:
      raise RuntimeError("Invalid")
  @property
  def humidity_oversample(self):
    return _BME680_SAMPLERATES[self._humidity_oversample]
  @humidity_oversample.setter
  def humidity_oversample(self, sample_rate):
    if sample_rate in _BME680_SAMPLERATES:
      self._humidity_oversample = _BME680_SAMPLERATES.index(sample_rate)
    else:
      raise RuntimeError("Invalid")
  @property
  def temperature_oversample(self):
      return _BME680_SAMPLERATES[self._temp_oversample]
  @temperature_oversample.setter
  def temperature_oversample(self, sample_rate):
    if sample_rate in _BME680_SAMPLERATES:
      self._temp_oversample = _BME680_SAMPLERATES.index(sample_rate)
    else:
      raise RuntimeError("Invalid")
  @property
  def filter_size(self):
    return _BME680_FILTERSIZES[self._filter]
  @filter_size.setter
  def filter_size(self, size):
    if size in _BME680_FILTERSIZES:
      self._filter = _BME680_FILTERSIZES[size]
    else:
      raise RuntimeError("Invalid")
  @property
  def temperature(self):
    self._perform_reading()
    calc_temp = (((self._t_fine * 5) + 128) / 256)
    return calc_temp / 100
  @property
  def pressure(self):
    self._perform_reading()
    var1 = (self._t_fine / 2) - 64000
    var2 = ((var1 / 4) * (var1 / 4)) / 2048
    var2 = (var2 * self._pressure_calibration[5]) / 4
    var2 = var2 + (var1 * self._pressure_calibration[4] * 2)
    var2 = (var2 / 4) + (self._pressure_calibration[3] * 65536)
    var1 = (((((var1 / 4) * (var1 / 4)) / 8192) *
      (self._pressure_calibration[2] * 32) / 8) +
      ((self._pressure_calibration[1] * var1) / 2))
    var1 = var1 / 262144
    var1 = ((32768 + var1) * self._pressure_calibration[0]) / 32768
    calc_pres = 1048576 - self._adc_pres
    calc_pres = (calc_pres - (var2 / 4096)) * 3125
    calc_pres = (calc_pres / var1) * 2
    var1 = (self._pressure_calibration[8] * (((calc_pres / 8) * (calc_pres / 8)) / 8192)) / 4096
    var2 = ((calc_pres / 4) * self._pressure_calibration[7]) / 8192
    var3 = (((calc_pres / 256) ** 3) * self._pressure_calibration[9]) / 131072
    calc_pres += ((var1 + var2 + var3 + (self._pressure_calibration[6] * 128)) / 16)
    return calc_pres/100
  @property
  def humidity(self):
    self._perform_reading()
    temp_scaled = ((self._t_fine * 5) + 128) / 256
    var1 = ((self._adc_hum - (self._humidity_calibration[0] * 16)) -
      ((temp_scaled * self._humidity_calibration[2]) / 200))
    var2 = (self._humidity_calibration[1] *
      (((temp_scaled * self._humidity_calibration[3]) / 100) +
       (((temp_scaled * ((temp_scaled * self._humidity_calibration[4]) / 100)) /
         64) / 100) + 16384)) / 1024
    var3 = var1 * var2
    var4 = self._humidity_calibration[5] * 128
    var4 = (var4 + ((temp_scaled * self._humidity_calibration[6]) / 100)) / 16
    var5 = ((var3 / 16384) * (var3 / 16384)) / 1024
    var6 = (var4 * var5) / 2
    calc_hum = (((var3 + var6) / 1024) * 1000) / 4096
    calc_hum /= 1000
    if calc_hum > 100:
      calc_hum = 100
    if calc_hum < 0:
      calc_hum = 0
    return calc_hum
  @property
  def altitude(self):
    pressure = self.pressure
    return 44330 * (1.0 - math.pow(pressure / self.sea_level_pressure, 0.1903))
  @property
  def gas(self):
    self._perform_reading()
    var1 = ((1340 + (5 * self._sw_err)) * (_LOOKUP_TABLE_1[self._gas_range])) / 65536
    var2 = ((self._adc_gas * 32768) - 16777216) + var1
    var3 = (_LOOKUP_TABLE_2[self._gas_range] * var1) / 512
    calc_gas_res = (var3 + (var2 / 2)) / var2
    return int(calc_gas_res)
  def _perform_reading(self):
    if (time.ticks_diff(self._last_reading, time.ticks_ms()) * time.ticks_diff(0, 1)
        < self._min_refresh_time):
      return
    self._write(_BME680_REG_CONFIG, [self._filter << 2])
    self._write(_BME680_REG_CTRL_MEAS,
      [(self._temp_oversample << 5)|(self._pressure_oversample << 2)])
    self._write(_BME680_REG_CTRL_HUM, [self._humidity_oversample])
    self._write(_BME680_REG_CTRL_GAS, [_BME680_RUNGAS])
    ctrl = self._read_byte(_BME680_REG_CTRL_MEAS)
    ctrl = (ctrl & 0xFC) | 0x01
    self._write(_BME680_REG_CTRL_MEAS, [ctrl])
    new_data = False
    while not new_data:
      data = self._read(_BME680_REG_MEAS_STATUS, 15)
      new_data = data[0] & 0x80 != 0
      time.sleep(0.005)
    self._last_reading = time.ticks_ms()
    self._adc_pres = _read24(data[2:5]) / 16
    self._adc_temp = _read24(data[5:8]) / 16
    self._adc_hum = struct.unpack('>H', bytes(data[8:10]))[0]
    self._adc_gas = int(struct.unpack('>H', bytes(data[13:15]))[0] / 64)
    self._gas_range = data[14] & 0x0F
    var1 = (self._adc_temp / 8) - (self._temp_calibration[0] * 2)
    var2 = (var1 * self._temp_calibration[1]) / 2048
    var3 = ((var1 / 2) * (var1 / 2)) / 4096
    var3 = (var3 * self._temp_calibration[2] * 16) / 16384
    self._t_fine = int(var2 + var3)
  def _read_calibration(self):
    coeff = self._read(_BME680_BME680_COEFF_ADDR1, 25)
    coeff += self._read(_BME680_BME680_COEFF_ADDR2, 16)
    coeff = list(struct.unpack('<hbBHhbBhhbbHhhBBBHbbbBbHhbb', bytes(coeff[1:39])))
    coeff = [float(i) for i in coeff]
    self._temp_calibration = [coeff[x] for x in [23, 0, 1]]
    self._pressure_calibration = [coeff[x] for x in [3, 4, 5, 7, 8, 10, 9, 12, 13, 14]]
    self._humidity_calibration = [coeff[x] for x in [17, 16, 18, 19, 20, 21, 22]]
    self._gas_calibration = [coeff[x] for x in [25, 24, 26]]
    self._humidity_calibration[1] *= 16
    self._humidity_calibration[1] += self._humidity_calibration[0] % 16
    self._humidity_calibration[0] /= 16
    self._heat_range = (self._read_byte(0x02) & 0x30) / 16
    self._heat_val = self._read_byte(0x00)
    self._sw_err = (self._read_byte(0x04) & 0xF0) / 16
  def _read_byte(self, register):
    return self._read(register, 1)[0]
  def _read(self, register, length):
    raise NotImplementedError()
  def _write(self, register, values):
    raise NotImplementedError()
class BME680_I2C(Adafruit_BME680):
  def __init__(self, i2c, address=0x77, debug=False, *, refresh_rate=10):
    self._i2c = i2c
    self._address = address
    self._debug = debug
    super().__init__(refresh_rate=refresh_rate)
  def _read(self, register, length):
    result = bytearray(length)
    self._i2c.readfrom_mem_into(self._address, register & 0xff, result)
    if self._debug:
      print("\t${:x} read ".format(register), " ".join(["{:02x}".format(i) for i in result]))
    return result
  def _write(self, register, values):
    if self._debug:
      print("\t${:x} write".format(register), " ".join(["{:02x}".format(i) for i in values]))
    for value in values:
      self._i2c.writeto_mem(self._address, register, bytearray([value & 0xFF]))
      register += 1
View raw code

Follow the next set of instructions for the IDE you’re using:

A. Upload BME680 library with uPyCraft IDE
B. Upload BME680 library with Thonny IDE
A. Upload BME680 library with uPyCraft IDE
This section shows how to upload a library using uPyCraft IDE. If you’re using Thonny IDE, read the next section.

1. Create a new file by pressing the New File button (1).

2. Copy the BME680 library code into that file. The BME680 library code can be found here.

3. After copying the code, save the file by pressing the Save button (2).

Install BME280 library MicroPython ESP32 ESP8266 uPyCraft IDE step 1
4. Call this new file “bme680.py” and press ok.

bme680.py new MicroPython file
5. Click the Download and Run button.

Install BME280 library MicroPython ESP32 ESP8266 uPyCraft IDE step 3
The file should be saved on the device folder with the name “bme680.py” as highlighted in the following figure.

uPyCraft IDE Save library file to device ESP32 ESP8266
Now, you can use the library functionalities in your code by importing the library.

B. Upload BME680 library with Thonny IDE
If you’re using Thonny IDE, follow the next steps:

1. Copy the library code to a new file. The BME680 library code can be found here.

2. Go to File > Save as…

Thonny IDE ESP32 ESP8266 MicroPython Save file library to device save as
3. Select save to “MicroPython device“:

Thonny IDE ESP32 ESP8266 MicroPython Save file library to device select
4. Name your file as bme680.py and press the OK button:

Thonny IDE ESP32 ESP8266 MicroPython Save file library to device name file
And that’s it. The library was uploaded to your board. To make sure that it was uploaded successfully, go to File > Save as… and select the MicroPython device. Your file should be listed there:

Thonny IDE ESP32 ESP8266 MicroPython Save file library to device saved
After uploading the library to your board, you can use the library functionalities in your code by importing the library.

Code Web Server – BME680 Temperature, Humidity, Pressure, and Gas Air Quality
Now that you know how to get temperature, humidity, pressure and gas from the BME680 sensor, we’ll display the sensor readings on a web server that you can access on your local network.

ESP32 ESP8266 MicroPython BME680 Web Server Test mobile responsive
For this example, you need three files:

bme680.py: this is the file that contains all the methods to use the BME680 sensor. That’s the file you’ve uploaded previously.
boot.py: runs when the device starts and sets up several configuration options like your network credentials, importing libraries, setting the pins, etc.
main.py: this is the main script where we’ll handle the web server. It executes immediately after the boot.py.
Note: It is a good practice to include the boot.py and main.py files. However, if you prefer, you can include all the code in the main.py file.

boot.py
Create a new file in your IDE called boot.py and copy the following code.

# Complete project details at https://RandomNerdTutorials.com/micropython-bme680-esp32-esp8266/

try:
  import usocket as socket
except:
  import socket
  
from time import sleep

from machine import Pin, I2C
import network

import esp
esp.osdebug(None)

import gc
gc.collect()

from bme680 import *

# ESP32 - Pin assignment
i2c = I2C(scl=Pin(22), sda=Pin(21))
# ESP8266 - Pin assignment
#i2c = I2C(scl=Pin(5), sda=Pin(4))

ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'

station = network.WLAN(network.STA_IF)

station.active(True)
station.connect(ssid, password)

while station.isconnected() == False:
  pass

print('Connection successful')
print(station.ifconfig())
View raw code

This file imports the necessary libraries, defines the I2C pins to connect to the sensor and connects to your network.

In the code, we’re using the ESP32 I2C pins:

i2c = I2C(scl=Pin(22), sda=Pin(21))
If you’re using the ESP8266, comment the previous line and uncomment the following:

i2c = I2C(scl=Pin(5), sda=Pin(4))
Then, insert your network credentials in the following variables:

ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'
main.py
In the main.py file is where we’ll create the web server and handle the requests. Copy the following code to your main.py file.

# Complete project details at https://RandomNerdTutorials.com/micropython-bme680-esp32-esp8266/

def web_page():
  bme = BME680_I2C(i2c=i2c)
  
  html = """<html><head><title>ESP with BME680</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,"><style>body { text-align: center; font-family: "Trebuchet MS", Arial;}
  table { border-collapse: collapse; margin-left:auto; margin-right:auto; }
  th { padding: 12px; background-color: #0043af; color: white; }
  tr { border: 1px solid #ddd; padding: 12px; }
  tr:hover { background-color: #bcbcbc; }
  td { border: none; padding: 12px; }
  .sensor { color:white; font-weight: bold; background-color: #bcbcbc; padding: 1px;
  </style></head><body><h1>ESP with BME680</h1>
  <table><tr><th>MEASUREMENT</th><th>VALUE</th></tr>
  <tr><td>Temp. Celsius</td><td><span class="sensor">""" + str(round(bme.temperature, 2)) + """ C</span></td></tr>
  <tr><td>Temp. Fahrenheit</td><td><span class="sensor">""" + str(round((bme.temperature) * (9/5) + 32, 2))  + """ F</span></td></tr>
  <tr><td>Pressure</td><td><span class="sensor">""" + str(round(bme.pressure, 2)) + """ hPa</span></td></tr>
  <tr><td>Humidity</td><td><span class="sensor">""" + str(round(bme.humidity, 2)) + """ %</span></td></tr>
  <tr><td>Gas</td><td><span class="sensor">""" + str(round(bme.gas/1000, 2)) + """ KOhms</span></td></tr></body></html>"""
  return html

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)

while True:
  try:
    if gc.mem_free() < 102000:
      gc.collect()
    conn, addr = s.accept()
    conn.settimeout(3.0)
    print('Got a connection from %s' % str(addr))
    request = conn.recv(1024)
    conn.settimeout(None)
    request = str(request)
    print('Content = %s' % request)
    response = web_page()
    conn.send('HTTP/1.1 200 OK\n')
    conn.send('Content-Type: text/html\n')
    conn.send('Connection: close\n\n')
    conn.sendall(response)
    conn.close()
  except OSError as e:
    conn.close()
    print('Connection closed')
View raw code

This code creates a socket server that sends an HTML page with the latest sensor readings when it receives a request on the ESP32 or ESP8266 IP address.

Basically, we have a function called web_page() that returns the HTML to build up the web page with the latest sensor readings. This HMTL text builds a table to display the readings:

def web_page():
  bme = BME680_I2C(i2c=i2c)
  
  html = """<html><head><title>ESP with BME680</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:,"><style>body { text-align: center; font-family: "Trebuchet MS", Arial;}
  table { border-collapse: collapse; margin-left:auto; margin-right:auto; }
  th { padding: 12px; background-color: #0043af; color: white; }
  tr { border: 1px solid #ddd; padding: 12px; }
  tr:hover { background-color: #bcbcbc; }
  td { border: none; padding: 12px; }
  .sensor { color:white; font-weight: bold; background-color: #bcbcbc; padding: 1px;
  </style></head><body><h1>ESP with BME680</h1>
  <table><tr><th>MEASUREMENT</th><th>VALUE</th></tr>
  <tr><td>Temp. Celsius</td><td><span class="sensor">""" + str(round(bme.temperature, 2)) + """ C</span></td></tr>
  <tr><td>Temp. Fahrenheit</td><td><span class="sensor">""" + str(round((bme.temperature) * (9/5) + 32, 2))  + """ F</span></td></tr>
  <tr><td>Pressure</td><td><span class="sensor">""" + str(round(bme.pressure, 2)) + """ hPa</span></td></tr>
  <tr><td>Humidity</td><td><span class="sensor">""" + str(round(bme.humidity, 2)) + """ %</span></td></tr>
  <tr><td>Gas</td><td><span class="sensor">""" + str(round(bme.gas/1000, 2)) + """ KOhms</span></td></tr></body></html>"""
  return html
Then, we create a socket server that sends the HTML when it gets a request. The HTML text is then saved on the response variable:

response = web_page()
And sent to the client:

conn.sendall(response)

#EXAMPLE-4 DS18B20 Temperature Sensor with esp32 yaa iske jagah me hum DHT sensor ka bhi use kar sakte hai
#step-1 boot.py
try:
  import usocket as socket
except:
  import socket
  
from time import sleep
from machine import Pin
import onewire, ds18x20
 
import network
 
import esp
esp.osdebug(None)
 
import gc
gc.collect()
 
ds_pin = Pin(22)
ds_sensor = ds18x20.DS18X20(onewire.OneWire(ds_pin))
 
ssid = 'Alexahome'
password = 'loranthus'
 
station = network.WLAN(network.STA_IF)
 
station.active(True)
station.connect(ssid, password)
 
while station.isconnected() == False:
  pass
 
print('Connection successful')
print(station.ifconfig())

#step-2 main.py
def read_ds_sensor():
  roms = ds_sensor.scan()
  print('Found DS devices: ', roms)
  print('Temperatures: ')
  ds_sensor.convert_temp()
  for rom in roms:
    temp = ds_sensor.read_temp(rom)
    if isinstance(temp, float):
      msg = round(temp, 2)
      print(temp, end=' ')
      print('Valid temperature')
      return msg
  return b'0.0'
  
def web_page():
  temp = read_ds_sensor()
  html = """<!DOCTYPE HTML><html><head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  <style> html { font-family: Arial; display: inline-block; margin: 0px auto; text-align: center; }
    h2 { font-size: 3.0rem; } p { font-size: 3.0rem; } .units { font-size: 1.2rem; } 
    .ds-labels{ font-size: 1.5rem; vertical-align:middle; padding-bottom: 15px; }
  </style></head><body><h2>ESP32 DS18B20 WebServer</h2>
  <p><i class="fas fa-thermometer-half" style="color:#059e8a;"></i> 
    <span class="ds-labels">Temperature</span>
    <span id="temperature">""" + str(temp) + """</span>
    <sup class="units">&deg;C</sup>
  </p>
    <p><i class="fas fa-thermometer-half" style="color:#059e8a;"></i> 
    <span class="ds-labels">Temperature</span>
    <span id="temperature">""" + str(round(temp * (9/5) + 32.0, 2)) + """</span>
    <sup class="units">&deg;F</sup>
  </p></body></html>"""
  return html
 
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)
 
while True:
  try:
    if gc.mem_free() < 102000:
      gc.collect()
    conn, addr = s.accept()
    conn.settimeout(3.0)
    print('Got a connection from %s' % str(addr))
    request = conn.recv(1024)
    conn.settimeout(None)
    request = str(request)
    print('Content = %s' % request)
    response = web_page()
    conn.send('HTTP/1.1 200 OK\n')
    conn.send('Content-Type: text/html\n')
    conn.send('Connection: close\n\n')
    conn.sendall(response)
    conn.close()
  except OSError as e:
    conn.close()
    print('Connection closed')

#EXAMPLE-6 DHT sensor random nerd tutorial micropython
#step-1 boot.py
try:
  import usocket as socket
except:
  import socket

import network
from machine import Pin
import dht

import esp
esp.osdebug(None)

import gc
gc.collect()

ssid = 'REPLACE_WITH_YOUR_SSID'
password = 'REPLACE_WITH_YOUR_PASSWORD'

station = network.WLAN(network.STA_IF)

station.active(True)
station.connect(ssid, password)

while station.isconnected() == False:
  pass

print('Connection successful')
print(station.ifconfig())

sensor = dht.DHT22(Pin(14))
#sensor = dht.DHT11(Pin(14))

#step-2 main.py
def read_sensor():
  global temp, hum
  temp = hum = 0
  try:
    sensor.measure()
    temp = sensor.temperature()
    hum = sensor.humidity()
    if (isinstance(temp, float) and isinstance(hum, float)) or (isinstance(temp, int) and isinstance(hum, int)):
      msg = (b'{0:3.1f},{1:3.1f}'.format(temp, hum))

      # uncomment for Fahrenheit
      #temp = temp * (9/5) + 32.0

      hum = round(hum, 2)
      return(msg)
    else:
      return('Invalid sensor readings.')
  except OSError as e:
    return('Failed to read sensor.')

def web_page():
  html = """<!DOCTYPE HTML><html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
  <style>
    html {
     font-family: Arial;
     display: inline-block;
     margin: 0px auto;
     text-align: center;
    }
    h2 { font-size: 3.0rem; }
    p { font-size: 3.0rem; }
    .units { font-size: 1.2rem; }
    .dht-labels{
      font-size: 1.5rem;
      vertical-align:middle;
      padding-bottom: 15px;
    }
  </style>
</head>
<body>
  <h2>ESP DHT Server</h2>
  <p>
    <i class="fas fa-thermometer-half" style="color:#059e8a;"></i> 
    <span class="dht-labels">Temperature</span> 
    <span>"""+str(temp)+"""</span>
    <sup class="units">&deg;C</sup>
  </p>
  <p>
    <i class="fas fa-tint" style="color:#00add6;"></i> 
    <span class="dht-labels">Humidity</span>
    <span>"""+str(hum)+"""</span>
    <sup class="units">%</sup>
  </p>
</body>
</html>"""
  return html

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)

while True:
  conn, addr = s.accept()
  print('Got a connection from %s' % str(addr))
  request = conn.recv(1024)
  print('Content = %s' % str(request))
  sensor_readings = read_sensor()
  print(sensor_readings)
  response = web_page()
  conn.send('HTTP/1.1 200 OK\n')
  conn.send('Content-Type: text/html\n')
  conn.send('Connection: close\n\n')
  conn.sendall(response)
  conn.close()

#EX-6 control the rgb led from the webpage
try:
    import usocket as socket
except:
    import socket
  
from machine import Pin, PWM
import network
import esp
esp.osdebug(None)
import gc
gc.collect()

# Replace with your network credentials
ssid = "Airtel_tejv_3002"
password = "air73137"

# GPIO pins for RGB LEDs
redPin = 13     # GPIO13
greenPin = 12   # GPIO12
bluePin = 14    # GPIO14

# Setting PWM frequency and bit resolution
freq = 5000
resolution = 8

# Connect to Wi-Fi network
station = network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid, password)
while not station.isconnected():
    pass
print("Connection successful")
print(station.ifconfig())

# Configure PWM channels for RGB LEDs
red_pwm = PWM(Pin(redPin), freq=freq, duty=0)
green_pwm = PWM(Pin(greenPin), freq=freq, duty=0)
blue_pwm = PWM(Pin(bluePin), freq=freq, duty=0)

# Function to generate HTML for the web page
def web_page():
    html = """<!DOCTYPE html><html><head><title>ESP RGB LED Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:,">
    <style>html { font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center; }
    h1 { color: #0F3376; padding: 2vh; }
    p { font-size: 1.5rem; }
    .button { display: inline-block; background-color: #e7bd3b; border: none; border-radius: 4px; 
    color: white; padding: 16px 40px; text-decoration: none; font-size: 30px; margin: 2px; cursor: pointer; }
    .colorpicker { width: 100px; height: 50px; font-size: 14px; }</style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.0.4/jscolor.min.js"></script>
    </head><body><h1>ESP RGB LED Control</h1>
    <p>Red: <input class="colorpicker" id="red" onchange="updateColor()" value="FF0000"></p>
    <p>Green: <input class="colorpicker" id="green" onchange="updateColor()" value="00FF00"></p>
    <p>Blue: <input class="colorpicker" id="blue" onchange="updateColor()" value="0000FF"></p>
    <p><a href="/?led=on"><button class="button">ON</button></a> 
    <a href="/?led=off"><button class="button">OFF</button></a></p>
    <script>
    function updateColor() {
        var red = document.getElementById("red").value;
        var green = document.getElementById("green").value;
        var blue = document.getElementById("blue").value;
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function() {
            if (this.readyState == 4 && this.status == 200) {
                console.log("Color updated:", red, green, blue);
            }
        };
        xhttp.open("GET", "/?r=" + red + "g=" + green + "b=" + blue, true);
        xhttp.send();
    }
    </script></body></html>"""
    return html

# Create TCP/IP server
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)

# Main loop to handle client connections and requests
while True:
    conn, addr = s.accept()
    print('Got a connection from %s' % str(addr))
    
    request = conn.recv(1024)
    request = str(request)
    print('Content = %s' % request)
    
    # Check if LED control command received
    led_on = request.find('/?led=on')
    led_off = request.find('/?led=off')
    if led_on == 6:
        print('LED ON')
        # Code to turn LED ON
    if led_off == 6:
        print('LED OFF')
        # Code to turn LED OFF

    # Parse RGB values from request
    if "/?r=" in request and "g=" in request and "b=" in request:
        r_index = request.find("r=") + 2
        g_index = request.find("g=") + 2
        b_index = request.find("b=") + 2
        r_value = int(request[r_index:r_index+2], 16)
        g_value = int(request[g_index:g_index+2], 16)
        b_value = int(request[b_index:b_index+2], 16)
        
        # Update PWM duty cycles for RGB LEDs
        red_pwm.duty(r_value)
        green_pwm.duty(g_value)
        blue_pwm.duty(b_value)
    
    # Generate HTML response and send to client
    response = web_page()
    conn.send('HTTP/1.1 200 OK\n')
    conn.send('Content-Type: text/html\n')
    conn.send('Connection: close\n\n')
    conn.sendall(response)
    
    # Close connection
    conn.close()

#rgb led color picker to control the rgb led
import socket
from machine import Pin
import network
import esp
esp.osdebug(None)
import gc
gc.collect()

# Initialize network connection
ssid = "Airtel_tejv_3002"
password = "air73137"
station = network.WLAN(network.STA_IF)
station.active(True)
station.connect(ssid, password)
while not station.isconnected():
    pass

print("Wi-Fi connected:", station.ifconfig())

# Initialize GPIO for LED control (assuming RGB LED setup)
led_r = Pin(19, Pin.OUT)
led_g = Pin(18, Pin.OUT)
led_b = Pin(5, Pin.OUT)

def web_page():
    # HTML content for the color picker webpage
    html = """<!DOCTYPE html>
    <html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="icon" href="data:,">
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jscolor/2.0.4/jscolor.min.js"></script>
    </head>
    <body>
        <div class="container">
            <div class="row">
                <h1>ESP Color Picker</h1>
            </div>
            <div>
                <input class="jscolor {onFineChange:'update(this)'}" id="rgb">
                <button class="btn btn-primary" onclick="sendColor(event)">Send Color</button>
            </div>
        </div>
        <script>
            function update(picker) {
                document.getElementById('rgb').value = Math.round(picker.rgb[0]) + ',' + Math.round(picker.rgb[1]) + ',' + Math.round(picker.rgb[2]);
            }
            function sendColor(event) {
                event.preventDefault(); // Prevent default form submission
                var rgbValue = document.getElementById('rgb').value;
                var url = '/set_color?rgb=' + rgbValue;
                fetch(url)
                    .then(response => {
                        console.log('Color sent successfully');
                        location.reload(); // Reload the page after sending color
                    })
                    .catch(error => {
                        console.error('Error sending color:', error);
                    });
            }
        </script>
    </body>
    </html>
    """
    return html

# Create a TCP/IP socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind(('', 80))
s.listen(5)

def parse_led_control(request):
    if '/set_color' in request:
        rgb_start = request.find('/set_color?rgb=')
        if rgb_start != -1:
            rgb_end = request.find(' ', rgb_start)
            if rgb_end != -1:
                rgb_values = request[rgb_start + len('/set_color?rgb='):rgb_end]
                print(f'Color received from web: {rgb_values}')  # Print the color value received from the web
                rgb_values = rgb_values.split(',')
                if len(rgb_values) == 3:
                    try:
                        r = int(rgb_values[0], 16)  # Convert hexadecimal to integer
                        g = int(rgb_values[1], 16)
                        b = int(rgb_values[2], 16)
                        set_led_color(r, g, b)
                        print(f'Set LED color: R={r}, G={g}, B={b}')
                    except ValueError as e:
                        print('Error parsing RGB values:', e)

def set_led_color(r, g, b):
    # Assuming common anode RGB LED, where 0 is fully on and 1 is fully off
    led_r.value(1 - (r / 255))
    led_g.value(1 - (g / 255))
    led_b.value(1 - (b / 255))

def send_response(conn, content_type='text/html', content=''):
    conn.send('HTTP/1.1 200 OK\n')
    conn.send(f'Content-Type: {content_type}\n')
    conn.send('Connection: close\n')
    if content:
        conn.send(f'Content-Length: {len(content)}\n')
    conn.send('\n')
    if content:
        conn.send(content)

while True:
    conn, addr = s.accept()
    print('Got a connection from %s' % str(addr))
    request = conn.recv(1024)
    request = str(request)
    print('Content = %s' % request)
    
    parse_led_control(request)  # Check for LED control commands
    
    response = web_page()
    send_response(conn, content_type='text/html', content=response)
    conn.close()

